const _ = require('lodash')
const { ethers } = require('ethers')
const provider = new ethers.providers.JsonRpcProvider(process.env.RPC)
const contractABI = require('../ABIs/SFarm.json').abi
const LogsStateModel = require('../models/LogsStateModel')
const SFarm = new ethers.Contract(process.env.FARM, contractABI, provider)
const FARM_GENESIS = parseInt(process.env.FARM_GENESIS)

let DEBUG_HEAD

const processMaskLogs = ({ logs }) => {
    return _.pickBy(logs
        .map(({ data, topics }) => ({
            ['0x' + topics[1].substr(26)]: parseInt(data),
        }))
        .reduce((a, b) => ({ ...a, ...b }), {})
    )
}

const filter = SFarm.filters.AuthorizeAdmin(null, null)
const filters = [filter]
const addresses = filters.map(f => f.address)

module.exports = (key) => ({
    key,

    getRequests: (past) => {
        if (past) {
            return [
                ...filters.map(f => ({...f, lo: 8207000})),
                ...filters.map(f => ({...f, lo: 8200000, hi: 8201000})),                     // past range forward
                ...filters.map(f => ({...f, lo: 8202000, hi: 8204000})),                     // past range forward
                ...filters.map(f => ({...f, lo: 8203000, hi: 8206000, backward: true})),     // past range backward
            ]
        }
        return filters.map(f => ({
            topics: f.topics,
            start: FARM_GENESIS,
        }))
    },

    processLogs: async ({ logs, fromBlock, toBlock, latest, past }) => {
        logs = logs
            .filter(l => addresses.includes(l.address))
            .filter(log => log.topics[0] === filter.topics[0])
        console.error(`${key}.processLogs`, logs.length, fromBlock, toBlock)

        // DEBUG
        if (!past && latest) {
            if (DEBUG_HEAD != null && DEBUG_HEAD != fromBlock-1) {
                throw new Error(`DEBUG: missing blocks: ${DEBUG_HEAD}-${fromBlock}`)
            }
            DEBUG_HEAD = toBlock
        }

        // const stateValue = processMaskLogs({
        //     logs: logs.filter(log => log.topics[0] === filter.topics[0])
        // });
    
        // const lastState = await LogsStateModel.findOne({
        //     key
        // }).lean();

        // return LogsStateModel.updateOne(
        //     { key },
        //     {
        //         value: {
        //             ...(lastState && lastState.value),
        //             ...stateValue,
        //         }
        //     },
        //     { upsert: true },
        // );
    }
})
